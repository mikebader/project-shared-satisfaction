
## Variables

### Dependent Variables
#### Satisfaction Variable
The current neighborhood satisfaction variable comes from Question 5: "How satisfied are you with your neighborhood as a place to live?" Responses of "Extremely satisfied" and "Very satisfied" are coded as "satisfied"; other responses ("Somewhat satisfied" and "Not at all satisfied" and coded as "unsatisfied"). 

#### Neighborhood Change Variable
The satisfaction with neighborhood change variable comes from Question 9: "Looking back over the past five years or so, would you say that your neighborhood has:" Response options "Become a much better place to live" and "Become a somewhat better place to live" are coded as "better" and the other three responses are coded as "not better". 

```{r dependent-variables}
dataDIR <- '~/work/data/dcas/dcas2016/'
load(paste0(dataDIR,'Dataset/R/DCAS_2016_weighted.Rdata'))

sum(!is.na(dcas$dem.race))

dcas$satisfied <- dcas$nhd.satisfaction %in% c(
                       'Extremely satisfied','Very satisfied')
table(dcas[, c('nhd.satisfaction','satisfied')])
dcas$extremely_satisfied <- as.numeric(dcas$nhd.satisfaction=='Extremely satisfied')
table(dcas[, c('nhd.satisfaction','extremely_satisfied')])

dcas$better <- dcas$nhd.change %in% c(
                       'Much better', 'Somewhat better')
table(dcas[, c('nhd.change','better')])
dcas$much_better <- dcas$nhd.change=='Much better'
table(dcas[, c('nhd.change','much_better')])
```

### Preferences for Other Communities
```{r rename-commvars}
## Change names to have search dimension first and commname second
## Help on regex part: https://stackoverflow.com/questions/952275/regex-group-capture-in-r-with-multiple-capture-groups
search.vars <- grep('nhd\\.srch.+\\.', names(dcas), value=TRUE)
new_search_matches <- regmatches(
    search.vars, regexec('nhd\\.srch\\.(.+)\\.(.+)$', search.vars))
new_search_names <- sapply(new_search_matches, function(x){
    paste(rev(x[2:3]), collapse='_')})
names(dcas)[names(dcas)%in%search.vars] <- new_search_names
N <- sum(is.na(dcas$dem.race))
```
### Independent Variable
The independent variable for these analyses is self-identified race that has been recoded to represent non-Latinx white alone, non-Latinx black alone or in combination with other races, Latinx of any race, and non-Latinx Asian or Pacific Islander alone or in combination with any race except black. Respondents with other races were dropped from the analysis (N=`r N`). 

```{r independent-variables}
table(dcas$dem.race, useNA='always')
means <- prop.table(table(dcas$dem.race))
names <- c("\\emph{Race}&&\\\\Asian or Pacific Islander", "Black", "Latinx", "White")
dcas$dem.race <- relevel(dcas$dem.race, ref='white')
```

### Control Variables
I included control variables in the models. All control variables were centered at their means. 

**Demographic characteristics**

* *Age*, calculated from answer to Question 49: "In what year were you born?"

* *Foreign born*, answer to Question 58: "Where were you born?"

* *Gender*, male or female

* *Kids*, if answer to Question 2--"How many children ages 17 or under live in your household?"--is greater than zero

* *Marital status*, if answer to Question 60--"What is your marital status"-- is "Now married or in a married-style arrangement"

```{r demographic-variables}
center <- function(x) { ## Function to mean-center but not scale vars
    scale(as.numeric(dcas[[x]]), scale=FALSE)
}

dcas$agec <- scale(dcas$dem.age, scale=FALSE)
dcas$forbornc <- center('dem.forborn')
dcas$man <- dcas$dem.gender.mf=='Male'
dcas$manc <- center('man')
dcas$kids <- as.numeric(as.character(dcas$q2)) > 0
dcas$kids[as.numeric(as.character(dcas$q2)) > 90] <- NA
dcas$kidsc <- center('kids')
dcas$married <- grepl("Now married", dcas$dem.marital.stat)
table(dcas[,c('dem.marital.stat','married')]) ##Check recoding
dcas$marriedc <- center('married')

## Save values for descriptive table
means <- c(means, apply(
    dcas[,c('dem.age', 'dem.forborn', 'man', 'kids', 'married')],2, mean, na.rm=TRUE))
names <- c(names, 
           c('\\emph{Demographics}&&\\\\Age', 'Foreign Born', 'Man', 
             'Children present', 'Married'))
```
**Economic Status**

* *Educational attainment*, five categories based on Question 59, "What is the highest level of school you have completed or the highest degree you have received?"
* *Income*, four categories based on Question 64, "Last year, that is in 2015, what was your total family income from all sources before taxes?"

```{r economic-variables}
educ_dummies <- paste0('educ',1:5)
dcas[,educ_dummies] <- lapply(1:5,
        function(i) {unclass(dcas$dem.educ.attain)==i})
for(i in 1:5) { ##Check recoding
    print(table(dcas[,c('dem.educ.attain',paste0('educ',i))]))
}
dcas[,c(paste0(educ_dummies,'c'))] <- scale(dcas[,paste0('educ',1:5)], 
                                          scale=FALSE)
educ_names <- levels(dcas$dem.educ.attain)
educ_names[1] <- paste0("\\emph{Educational Attainment}&&\\\\", educ_names[1])

inc_dummies <- paste0('inc',1:4)
dcas[,inc_dummies] <- lapply(1:4,
        function(i) {unclass(dcas$dem.income.cat4)==i})
for(i in 1:4) { ## Check recoding
    print(table(dcas[,c('dem.income.cat4',paste0('inc',i))]))
}
dcas[,c(paste0(inc_dummies, 'c'))] <- scale(dcas[,paste0('inc',1:4)],
                                         scale=FALSE)
inc_names <- sanitize(levels(dcas$dem.income.cat4))
inc_names[1] <- paste0("\\emph{Income}&&\\\\", inc_names[1])
means <- c(means, apply(dcas[, c(educ_dummies, inc_dummies)], 2, mean, na.rm=TRUE))
names <- c(names, educ_names, inc_names)
```

**Neighborhood Experience**

* *Years in neighborhood*, based on Question 4: "How many years have you lived in your current neighborhood?"

* *Neighborhood size*, based on Question 7: "How many blocks are in the area that you think of as your neighborhood?"

```{r nhood-variables}
dcas$nhdyrs <- as.numeric(as.character(dcas$q4))
dcas$nhdyrsc <- scale(dcas$nhdyrs, scale=FALSE)
qplot(dcas$nhdyrsc)

dcas$nhdsize1 <- unclass(dcas$nhd.size)%in%c(1,2)
dcas$nhdsize2 <- unclass(dcas$nhd.size)%in%c(3,4)
dcas$nhdsize3 <- unclass(dcas$nhd.size)==5
for (i in 1:3) { ## Check recoding
    print(table(dcas[, c('nhd.size',paste0('nhdsize',i))]))
}
nhd_dummies <- paste0('nhdsize',1:3)
dcas[, paste0(nhd_dummies,'c')] <- scale(dcas[, nhd_dummies], scale=FALSE)

dcas$quad <- dcas$neighborhood=='Global Neighborhood'
table(dcas[,c('neighborhood','quad')])
dcas$quadc <- center('quad')

means <- c(means, 
           apply(dcas[, c('nhdyrs', nhd_dummies, 'quad')], 2, mean, na.rm=TRUE))
names <- c(names, '\\emph{Neighborhood Experience}\\\\Years in Neighborhood', 
                  '1-9 blocks', '10-50 blocks', '>50 blocks', 
                  'Quadrivial Neighborhood')
```


## Descriptive Statistics
Descriptive statistics are calculated unweighted.

```{r descriptives}
names(means)
varnames <- names(means)[-1:-4]
sigmas <- c(rep(NA,4), apply(dcas[,varnames], 2, sd, na.rm=TRUE))
continuous_vars <- grep('age|nhdyrs',attr(sigmas, 'names'), perl=TRUE)
sigmas[-continuous_vars] <- NA

descriptives <- matrix(c(names, round(means, 2), round(sigmas, 2)), ncol=3)
descriptive_tbl <- as.table(descriptives)
colnames(descriptive_tbl) <- c('Variable', 'Mean', 'S.D.')
print.xtable(xtable(descriptive_tbl,
                    caption='Un-weighted means and standard deviations of independent and control variables',
                    align=c('l','l','p{.5in}','p{.5in}'), label='tab:descriptives'),
                booktabs=TRUE, 
                caption.placement='top',
                include.rownames=FALSE, 
                file='tables/descriptives.tex',
                sanitize.text.function = identity)
```

## Analysis
### Multiple Imputation & Survey Weights
Several variables have a substantial amount of missing data. I used the Amelia package to create five imputation datasets that will be combined for the final results. I then set up the survey dseign using the list of imputed datasets to account for the complex survey design. 

```{r weights}
vars <- c('satisfied', 'extremely_satisfied', 'better',  'much_better',
          'dem.race', 'agec', 'forbornc', 'manc', 'kidsc', 'marriedc', 
          'educ1c', 'educ2c', 'educ3c', 'educ5c', 'inc1c',
          'inc3c', 'inc4c', 'nhdyrsc', 'nhdsize1c', 'nhdsize3c', 'quadc',
          unlist(new_search_names))
idvars <- c('studycase','weight', 'sample_strata')
dcassub <- dcas[!is.na(dcas$dem.race), c(vars, idvars)]
nominals <- vars[!(vars %in% c('agec', 'nhdyrsc'))]
dcasmi <- amelia(dcassub, m=2, noms=nominals, emburn = c (500 , 500) , p2s = F, idvars=c('studycase','weight','sample_strata'))
dcassvy <- svydesign(id=~1,strata=~sample_strata,weights=~weight,data=imputationList(dcasmi$imputations))
```


### Satisfaction
#### Bivariate Analysis (Satisfaction by Race)
Plot the mean value of satisfaction by each racial group using survey weights. 

```{r dependent-descriptives}
mean_satisfied <- MIcombine(with(dcassvy,
                        svymean(~satisfied)))
mean_satisfied_nhoodtype <- MIcombine(with(dcassvy,
                        svyby(~satisfied, ~quadc, svymean)))
satisfied_nhoodtype <- MIcombine(with(dcassvy, 
                        svyglm(satisfied ~ quadc, family=quasibinomial)))
summary(satisfied_nhoodtype)
```
Overall, `r round(coef(mean_satisfied)[2], 2)*100` percent of residents in the sample were either very or extremely satisfied with their neighborhoods; `r round(coef(mean_satisfied_nhoodtype)[4], 2)*100` of residents in quadrivial neighborhoods and `r round(coef(mean_satisfied_nhoodtype)[3], 2)*100` of disproportionately Latino neighborhoods.

```{r satisfaction-bivariate}
satisfied_means <- MIcombine(with(dcassvy, 
                        svyby(~satisfied, ~dem.race, svymean)))
satisfied_ci <- 1.96*sqrt(diag(satisfied_means$variance))
satisfied_vals <- data.frame(dem.race=c('White','Asian','Black','Latinx'), 
                             satisfied=coef(satisfied_means)[5:8],
                             ci=satisfied_ci[5:8])
satisfied_plt <- ggplot(satisfied_vals, aes(x=dem.race, y=satisfied)) + 
    geom_errorbar(aes(ymin=satisfied-ci, ymax=satisfied+ci), width=0.1) +
    geom_point() +
    scale_y_continuous(limits=c(0,1), breaks=seq(0,1,.20)) +
    labs(y='Proportion', x='Race')
satisfied_plt
ggsave('images/satisfied_descriptive.png', plot=satisfied_plt,
            height=3, width=4, units='in')
```

 


#### Multivariate Analysis
Run three models. The first includes only race; the second adds demographic characteristics; and the third adds the resident's experience with the neighborhood. Results are saved to LaTeX table saved at `analysis/tables/satisfaction.tex` (code suppressed). 

**Satisfied.**

```{r satisfied-analysis, warning=FALSE, results='hide'}
m1 <- 'dem.race'
m2 <- paste0(m1, '+ agec + forbornc + manc + kidsc + marriedc + ',
             'educ1c + educ2c + educ3c + educ5c + inc1c + inc3c + inc4c')
m3 <- paste0(m2, '+ nhdyrsc + nhdsize1c + nhdsize3c + quadc')
m1_sat <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('satisfied ~',m1)), family=binomial)
))
summary(m1_sat)
m2_sat <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('satisfied ~', m2)), family=quasibinomial)
))        
summary(m2_sat)
m3_sat <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('satisfied ~', m3)), family=quasibinomial)
))
summary(m3_sat)
```

```{r report-satisfaction-analysis}
regression_labels <- c('Asian','Black','Latinx',
                       'Age','Foreign Born','Male',
                       'Children Present', 'Married',
                       levels(dcas$dem.educ.attain)[c(1:3,5)],
                       levels(dcas$dem.income.cat4)[c(1,3:4)],
                       'Years in neighborhood',
                       '1-9 blocks', '$>$50 blocks',
                       'Quadrivial Neighborhood'
                       )
sat_tbl <- report_models(m1_sat, m2_sat, m3_sat, reglabels=regression_labels,
                caption=paste0('Estimated coefficients predicting ',
                               ' neighborhood satisfaction'),
                label='tab:satisfaction')
sat_tbl
cat(to_latex(sat_tbl), file='tables/satisfaction.tex')
```

Those who perceived their neighborhoods to be 1-9 blocks were `r round(exp(coef(m3_sat)['nhdsize1c']),3)` as likely to find satisfaction in their neighborhood. Those who perceived their neighborhoods to be greater than 50 blocks were `r round(exp(coef(m3_sat)['nhdsize3c']),3)` as likely to find satisfaction, but the difference was not distinguishable from those who perceived their neighborhoods to be between 10 and 50 blocks. 

**Extremely Satisfied.** Calculate the proportion of respondents who are *extremely* satisfied by each racial group. 

```{r bivariate-extremely-satisfied}
extreme_means <- MIcombine(with(dcassvy,
                    svyby(~extremely_satisfied, ~dem.race, svymean)
                    ))
extreme_diffs <- MIcombine(with(dcassvy, 
                    svyglm(extremely_satisfied ~ dem.race, family=quasibinomial)
                    ))
extreme_prob_white <- exp(coef(extreme_diffs)[1])/(1+exp(coef(extreme_diffs)[1]))
extreme_odds <- exp(coef(extreme_diffs))

```

`r round(extreme_prob_white, 2)*100` percent of white residents reported being extremely satisfied with their neighborhoods. That value was 
`r round(1/extreme_odds[['dem.raceapi']],2)` times higher than Asians, 
`r round(1/extreme_odds[['dem.raceblack']],2)` times higher than blacks, and 
`r round(1/extreme_odds[['dem.racelatino']],2)` times than Latinx residents. 

```{r extremely-satisfied-analysis, results='hide'}
m1_esat <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('extremely_satisfied ~', m1)), family=binomial)
))
summary(m1_esat)
m2_esat <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('extremely_satisfied ~', m2)),
            family=quasibinomial)
))        
summary(m2_esat)
m3_esat <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('extremely_satisfied ~', m3)),
            family=quasibinomial)
))
summary(m3_esat)
```

### Neighborhood Improvement

Calculate the proportion of respondents who indicated that they think that the neighborhood has gotten better in the past five years. 

```{r improvement-descriptives}
better_means <- MIcombine(with(dcassvy, 
                        svyby(~better, ~dem.race, svymean)))
better_means <- summary(better_means)
better_vals <- data.frame(dem.race=c('White','Asian','Black','Latinx'),
                          better=better_means[5:8,1],
                          ci=better_means[5:8,2])
better_plt <- ggplot(better_vals, aes(x=dem.race, y=better)) +
    geom_errorbar(aes(ymin=better-ci, ymax=better+ci), width=0.1) +
    geom_point() +
    scale_y_continuous(limits=c(0,1), breaks=seq(0,1,.20)) +
    labs(y='Proportion', x='Race')
better_plt
ggsave('images/better_descriptive.png', plot=better_plt,
            height=3, width=4, units='in')
better_model <- MIcombine(with(dcassvy, 
                    svyglm(better ~ dem.race, family=quasibinomial)))
```

The graph above shows that Latinos and Asians were more likely to say that the neighborhood has improved while blacks and whites are less likely to say that their neighborhoods have improved. The differences, however, are not statistically distinguishable. 

```{r improvement-analysis, warning=FALSE}
m3 <- paste(m3, "+ extremely_satisfied")
m1_bet <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('better ~', m1)), family=binomial)
))
summary(m1_bet)
m2_bet <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('better ~', m2)), family=binomial)
))
summary(m2_bet)
m3_bet <- MIcombine(with(dcassvy,
        svyglm(as.formula(paste('better ~', m3)), family=binomial)
))
summary(m3_bet)
```

```{r report-better-analysis, results='hide'}
regression_labels_bet <- c(regression_labels, 'Extremely satisfied')
bet_tbl <- report_models(m1_bet, m2_bet, m3_bet, 
                reglabels=regression_labels_bet,
                caption=paste0('Estimated coefficients predicting ',
                               'neighborhood improvement'),
                label='tab:improvement')
bet_tbl
cat(to_latex(bet_tbl), file='tables/improvement.tex')
```


**Extreme Improvement.**
But, there is a difference for those who say that the neighborhood has gotten "much better" over the past five years. Whites, on this measure, were much less likely to indicate that their neighborhoods have gotten much better. I examine whether that might be due to the fact that whites are more likely to say that they are "extremely satisfied" in their neighborhoods relative to other racial groups. 

```{r much-better-descriptives}
much_better_means <- MIcombine(with(dcassvy,
                        svyby(~much_better, ~dem.race, svymean)))
much_better_means <- summary(much_better_means)
much_better_vals <- data.frame(dem.race=c('White','Asian','Black','Latinx'), 
                               much_better=much_better_means[5:8,1], 
                               ci=much_better_means[5:8,2])
much_better_plt <- ggplot(much_better_vals, aes(x=dem.race, y=much_better)) +
    geom_errorbar(aes(ymin=much_better-ci, ymax=much_better+ci), width=0.1) +
    geom_point() +
    scale_y_continuous(limits=c(0,1), breaks=seq(0,1,.20)) +
    labs(y='Proportion', x='Race')
much_better_plt
ggsave('images/much_better_descriptive.png', plot=much_better_plt,
    height=3, width=4, units='in')
       
much_better_model <- MIcombine(with(dcassvy, 
                        svyglm(much_better ~ dem.race, family=quasibinomial)))
much_better_satis_model <- MIcombine(with(dcassvy, 
                        svyglm(much_better ~ dem.race + extremely_satisfied,
                               family=quasibinomial)))
betas <- much_better_satis_model$coefficients
odds <- exp(betas)
odds
list(coef(much_better_model), coef(much_better_satis_model))
```

Whites are 
`r round(odds[2],2)` times less likely than Asians, 
`r round(odds[3],2)` times less likely than blacks, and
`r round(odds[4],2)` times less likely than Latinxs to report that their neighborhoods have gotten "much better". Adding whether respondents were extremely satisfied with their neighborhood actually *exacerbated* racial differences in how likely respondents were to say that their neighborhood had gotten much better.


```{r much-better-analysis}
## Outcome: Much Better
m1_mbet <- MIcombine(with(dcassvy,
        svyglm(much_better ~ dem.race, family=binomial)
))
summary(m1_bet)
m2_mbet <- MIcombine(with(dcassvy,
        svyglm(much_better ~ dem.race + agec + forbornc + manc + kidsc + marriedc +
               educ1c + educ2c + educ3c + educ5c + inc1c + inc3c + inc4c,
            family=quasibinomial)
))        
summary(m2_bet)
m3_mbet <- MIcombine(with(dcassvy,
        svyglm(much_better ~ dem.race + agec + forbornc + manc + kidsc + marriedc +
                 educ1c + educ2c + educ3c + educ5c + inc1c + inc3c + inc4c +
                 nhdyrsc + nhdsize1c + nhdsize3c + quadc + extremely_satisfied,
            family=quasibinomial)
))
summary(m3_bet)
(mbet_odds <- exp(coef(m3_mbet)[2:4]))
```

```{r report-much-better-results}
mbet_tbl <- report_models(m1_mbet, m2_mbet, m3_mbet, 
                reglabels=regression_labels_bet,
                caption=paste0('Estimated coefficients predicting ',
                               'neighborhood has gotten ``much better\'\''),
                label='tab:muchbetter')
mbet_tbl
cat(to_latex(mbet_tbl), file='tables/muchbetter.tex')
```

### Consider Other Multiethnic Neighborhoods
Assess how residents of different races would consider other multiethnic neighborhoods in the DC area. First, analyze results by race descriptively. Second, analyze results with control variables. Create plots for both descriptive and analytic results.

#### Racial Composition in Selectable Neighborhoods
Plot the racial composition in the 11 selectable neighborhoods
Racial composition of selectable communities
```{r plot-racial-composition}
load(paste0(dataDIR, 'dataset/R/DCAS_2016_PreferenceLevel.Rdata'))
comms <- dcas_prefs[!duplicated(dcas_prefs$commname),]
comms <- comms[order(comms$pctnhw),]
comm_order <- comms$commname
comms_long <- gather(comms, commnum, values, pctnhw, pctnhb, pctlat, pctapi)
comms_long$commname <- ordered(comms_long$commname, levels=comm_order)
comms_long$commnum <- ordered(comms_long$commnum, levels=c('pctapi', 'pctnhb', 'pctlat', 'pctnhw'))

ggplot(comms_long, aes(x=commname, y=values, fill=commnum)) + geom_bar(stat='identity', position=position_stack()) + coord_flip()
```

#### Descriptive Analysis Where People Would Consider Moving


```{r future-descriptives}
srch_mean <- function(comm, dimension) {
    out_fmla <- as.formula(paste0('~ ',dimension, '_', comm))
    overall <- summary(MIcombine(with(dcassvy,
        svymean(out_fmla))))
    res <- MIcombine(with(dcassvy,
        svyby(out_fmla, ~dem.race, svymean)))
    res_df <- data_frame(prop=summary(res)[5:8, 1], 
                      se=summary(res)[5:8, 2],
                      comm=comm, race=levels(dcas$dem.race))
    res_df <- bind_rows(data_frame(prop=overall[2,1], se=overall[2,2], 
                     comm=comm, race='overall'), res_df)
    return(res_df)
}
# comm_names <- sapply(new_search_matches[seq(1,51,5)],function(x){x[2]})
## Ordered by state, county, distance from downtown
comm_names <- c('columbia.heights', 'brightwood', 
                'langley.park', 'hyattsville', 'greenbelt',
                'wheaton', 'germantown', 
                'arlington', 
                'annandale', 'huntington', 'herndon')
consider_means <- bind_rows(lapply(comm_names, srch_mean, 'cons'))
consider_means$ci <- 1.96*consider_means$se

nconsider_means <- bind_rows(lapply(comm_names, srch_mean, 'nc'))
nconsider_means$ci <- 1.96*nconsider_means$se
```

Analyze four models for each of the 11 communities: 

1. **Constant-only model** will be used to plot the distance of each racial group from the overall mean consideration of the neighborhood.

2. **Race-only model** will be used to analyze the influence of race accounting for no other demographic characteristics.

3. **Model with controls** will be used to analyze the influence of race accounting for other demographic characteristics. 

4. **Model with controls only** will be used to plot the distance of each racial group from the overall conditional mean. 

To do this, define the `srch_reg` function to run weighted regression with multiple imputation. Use the `srch_reg` function to cycle through each of the eleven outcomes. 


```{r consider-analysis}
load(paste0(dataDIR,'Dataset/R/DCAS_2016_PreferenceLevel.Rdata'))
srch_reg <- function(comm, dimension, indvars='dem.race') {
    outvar <- paste(dimension, comm, sep='_')
    fmla <- as.formula(paste(outvar, indvars, sep='~'))
    res <- MIcombine((with(dcassvy,
        svyglm(fmla, family=quasibinomial))))
}

## Constant-only
cons_constant <- lapply(comm_names, srch_reg, 'cons', '1')

## Race-only
cons_raceonly <- lapply(comm_names, srch_reg, 'cons')

## Race with controls
cons_racecont <- lapply(comm_names, srch_reg, 'cons', m2)

## Controls-only
cons_contonly <- lapply(comm_names, srch_reg, 'cons', sub('dem.race\\+','',m2))
```

Report the regression coefficients from the race-only and race-with-controls models. (The output of the huxtable is not pretty -- that needs to be fixed). 

```{r consider-report-analysis}
srch_tbl <- function(base, controls) {
    
    comm_titles <- str_to_title(gsub('\\.', ' ', comm_names))
    base_tbl <- huxreg(base, statistics=c(''), error_format = '', borders = 0)
    base_tbl[1,] <- c('', comm_titles)
    base_tbl[seq(2,8,2),1] <- c('Intercept', 'Asian', 'Black', 'Latino')
    base_tbl <- t(base_tbl[seq(2,8,2),])
    
    cont_tbl <- huxreg(controls, 
                       statistics=c(''), error_format='', borders=0,
                        coefs=c('(Intercept)', 'dem.raceapi', 'dem.raceblack',
                                'dem.racelatino'))
    cont_tbl[seq(2,8,2),1] <- c('Intercept', 'Asian', 'Black', 'Latino')
    cont_tbl <- cont_tbl[seq(2,8,2),]
    
    for(i in 1:4) {
        rownum <- i+4
        base_tbl <- insert_column(base_tbl, as.character(cont_tbl[i, ]),
                                  after=ncol(base_tbl))
    }
    insert_row(base_tbl, c('*** p < 0.001; ** p < 0.01; * p < 0.05',
                           rep('',ncol(base_tbl)-1)), 
               after=nrow(base_tbl))
    return(base_tbl)
}

cons_tbl <- srch_tbl(cons_raceonly, cons_racecont)
tex <- gsub('\\{table\\}', '\\{sidewaystable\\}', to_latex(cons_tbl))
cat(tex, file='tables/consider.tex')
```

Create a plot with the predicted probability for each racial group plotted for each community. Then draw a line from the predicted probability for a racial group to the overall predicted probability with controls. 

First, analyze the data with all controls (but not race). The centered variables make the intercept the grand mean unconditional on race. Save those values into a data frame called `cons_overall`.

Next, compute predicted probabilities for each of the racial groups from the models with controls. Create a long dataset with probabilities by each race for each community. Merge the long dataframe with the overall dataset created above.  

```{r future-plot-functions, include=FALSE}
ypos <- c(0,2,8,10,12,16,18,24,28,30,32)
counties <- list(name=c('Fairfax, VA', 'Arlington, VA', 'Montgomery, MD',
                        'Prince George\'s, MD', 'Washington, DC'),
                 x=c(30, 24, 17, 10, 1))
dodge_width <- 1
races <- c('white','asian','black','latino')

srch_gather <- function(res, overall=FALSE) {
    sumres <- summary(res)
    if(overall==FALSE) {
        logits <- sumres[1,1] + c(0, sumres[2:4,1])
        ci <- 1.96*sumres[1:4,2]
    }
    else {
        logits <- sumres[1,1]
        ci <- 1.96*sumres[1,2]
    }
    lci <- logits-ci
    uci <- logits+ci
    probs <- exp(logits)/(1+exp(logits))
    uci <- exp(logits+ci)/(1+exp(logits+ci))
    lci <- exp(logits-ci)/(1+exp(logits-ci))
    out <- matrix(c(probs,lci,uci), nrow=1)
}
make_prob_df <- function(regs, overall=FALSE) {
    reg_matrix <- t(sapply(regs, srch_gather, overall)) 
    if(overall==TRUE) {
        prob_df <- reg_matrix %>%
            as_data_frame() %>%
            mutate(comm=comm_names, pos=ypos)
        names(prob_df)[1:3] <- c('prob', 'lci', 'uci')
    }
    else {
        prob_df <- data.frame(
            prob=matrix(reg_matrix[,1:4], ncol=1),
            lci=matrix(reg_matrix[5:8], ncol=1),
            uci=matrix(reg_matrix[9:12], ncol=1), 
            race=rep(races, each=11), 
            comm=rep(comm_names, 4)
        )
    }
    return(prob_df)
}
srch_plots <- function(prob_dfs, prob_names, consider=TRUE) {
    plt_params <- if(consider==TRUE) list(ypos=.33, 
                                          ybreaks=seq(0,.25,0.05), 
                                          ylims=c(0,.35)) else
                                     list(ypos=.73,
                                          ybreaks=seq(0,.50,0.1),
                                          ylims=c(0,.75))
    for(i in 1:2) {
        df <- prob_dfs[[i]]
        plt <- ggplot(df, aes(x=pos, y=prob, shape=race)) +
            geom_errorbar(aes(ymin=prob_overall,ymax=prob),
                          position=position_dodge(dodge_width), width=0) +
            geom_point(size=2, position=position_dodge(dodge_width), fill='white') +
            annotate("text", x=counties$x, y=plt_params$ypos, 
                     label=counties$name, size=3, hjust=1) +
            scale_x_continuous(breaks=ypos,
                               labels=levels(df$comm)) +
            scale_y_continuous(breaks=plt_params$ybreaks, 
                               limits=plt_params$ylims) +
            labs(x='Community', y='Proportion') +
            coord_flip() +
            scale_shape_manual(values=c(21,22,23,24)) +
            theme_bw() + theme(
                panel.grid.minor = element_blank())
        ggsave(plt, file=sprintf('images/%s.png', prob_names[i]),
               units='in', width=8, height=4.5)
    }
}
```

```{r consider-plot-results}
## Relies on convenience functions in .Rmd that are not included in workbook
cons_constant_probs <- make_prob_df(cons_constant, overall=TRUE)
cons_overall_probs  <- make_prob_df(cons_contonly, overall=TRUE)
cons_raceonly_probs <- make_prob_df(cons_raceonly) %>%
    left_join(cons_constant_probs, by='comm', suffix=c('','_overall')) %>%
    as_tibble()
cons_racecont_probs <- make_prob_df(cons_racecont) %>%
    left_join(cons_overall_probs, by='comm', suffix=c('', '_overall')) %>%
    as_tibble()

prob_dfs <- list(cons_raceonly_probs, cons_racecont_probs)
prob_names <- c('consider', 'consider_controls')
srch_plots(prob_dfs, prob_names)
```

```{r not-consider}
## Constant-only
ncons_constant <- lapply(comm_names, srch_reg, 'nc', '1')

## Race-only
ncons_raceonly <- lapply(comm_names, srch_reg, 'nc')

## Race with controls
ncons_racecont <- lapply(comm_names, srch_reg, 'nc', m2)

## Controls-only
ncons_contonly <- lapply(comm_names, srch_reg, 'nc', sub('dem.race\\+','',m2))

ncons_tbl <- srch_tbl(ncons_raceonly, ncons_racecont)
tex <- gsub('\\{table\\}', '\\{sidewaystable\\}', to_latex(ncons_tbl))
cat(tex, file='tables/consider.tex')


ncons_constant_probs <- make_prob_df(ncons_constant, overall=TRUE)
ncons_overall_probs  <- make_prob_df(ncons_contonly, overall=TRUE)
ncons_raceonly_probs <- make_prob_df(ncons_raceonly) %>%
    left_join(ncons_constant_probs, by='comm', suffix=c('','_overall')) %>%
    as_tibble()
ncons_racecont_probs <- make_prob_df(ncons_racecont) %>%
    left_join(ncons_overall_probs, by='comm', suffix=c('','_overall')) %>%
    as_tibble()

prob_dfs <- list(ncons_raceonly_probs, ncons_racecont_probs)
prob_names <- c('notconsider', 'notconsider_controls')
srch_plots(prob_dfs, prob_names, consider=FALSE)
```


##Notes
Consider only using educational attainment rather than both education and income. The two are highly correlated and would avoid having to impute. 

```{r}
ggplot(dcas, aes(x=dem.income.cat4,y=dem.educ.attain)) + geom_jitter()
```
