# Satisfaction *Within* Multiracial Neighborhoods

Change the reference value of the `sample_tract` variable to the tract with the median level of satisfaction among neighborhoods. When calculating the median, include only those tracts with at least two respondents. 

```{r wn-sample-tract}
mutrtall <- dcas16 %>%
    filter(neighborhood=="Global Neighborhood") %>%
    group_by(sample_tract) %>%
    summarize(
        N = n(), 
        tractsat = mean(satisfied)
        ) %>%
    ungroup()

mutrt <- mutrtall %>%
    filter(N>1) %>%
    arrange(tractsat)

medtrt <- mutrt$sample_tract[round(nrow(mutrt)/2)] %>% as.character()
medtrtval <- mutrt$tractsat[mutrt$sample_tract==medtrt]*100
dcas16svy <- update(
    dcas16svy, sample_tract = relevel(sample_tract, ref=medtrt)
)
## Add following to allow MIpredict to predict values at intercept
dcas16$sample_tract <- relevel(dcas16$sample_tract, ref=medtrt)

onlyone <- nrow(mutrtall) - nrow(mutrt)
onlyonelist <- mutrtall$sample_tract[mutrtall$N==1]
dcas16svy <- subset(dcas16svy, !(sample_tract %in% onlyonelist))
dcas16svy <- update(
    dcas16svy, sample_tract = relevel(factor(sample_tract), ref=medtrt))
```

The reference level for `sample_tract` was set to tract ``r medtrt``, in which `r round(medtrtval, 1)`% of residents reported being satisfied. 

Plot the distribution of respondents per tract. There are `r onlyone` tracts in the sample with a single respondent. There are `r round(mean(mutrt$N), 1)` respondents per tract on average (median=`r median(mutrt$N)`) with a maximum of `r max(mutrt$N)` respondents per tract. The sample size for the multiracial neighborhood resident sample used for analysis is `r nrow(dcas16svy$designs$imp1)`. 

```{r wn-n-per-nhood, echo=FALSE}
qplot(mutrtall$N, binwidth=1) +
    labs(
        x = "Respondents per tract",
        y = "Number of tracts"
    )

```

## Descriptive analysis of neighborhood satisfaction

Calculate the unconditional percentage of respondents who are satisfied in their neighborhood by race. 

```{r wn-desc}
racedfs <- list(
    dcas16svy,
    subset(dcas16svy, raceeth=="asian"),
    subset(dcas16svy, raceeth=="black"),
    subset(dcas16svy, raceeth=="latino"),
    subset(dcas16svy, raceeth=="white")
)
descwn <- lapply(racedfs, function(df){
    res <- with(df, svymean(~satisfied)) %>% MIcombine()
    n <- nrow(df$designs$imp1)
    list(mean16=coef(res)*100, se16=sqrt(vcov(res)[1,1])*100, n16 = n)
}) %>%
    bind_rows() %>%
    mutate(race = racelevs)
```

Create a 4x4 matrix where each cell represents the difference in satisfaction percentages between the racial group listed in the column and the racial group listed in the row. No values are entered for the bottom triangle or the diagonal.

```{r wn-difference-matrix}
## Create matrix of differences
diffmat <- matrix(rep(NA_real_, 16), nrow=4)
musat <- descwn$mean16[1]
muraces <- descwn$mean16[-1]
for(i in 1:3) {
    start <- i+1
    for(j in start:4) {
        diffmat[i, j] <- muraces[j] - muraces[i]
    }
}
colnames(diffmat) <- racelevs[-1]
```

Add an additional row to the top of the matrix that contains the percent of each group that reports being satisfied in their neighborhoods. Add an additional column to the left that contains a) the overall percent of residents who are satisfied living in multiracial neighborhoods and b) the difference between the percent of the racial group listed in the row and the overall mean. This table is saved to `tables/within_descriptives.tex`.

```{r wn-desc-tbl}
descwn_tbl <- bind_rows(
    descwn$mean16[-1] %>% set_names(racelevs[-1]), ## Percent satisfied in group
    as_tibble(diffmat)                             ## Diff. matrix
) %>%
    add_column(all = c(musat, muraces - musat), .before = 1)
names(descwn_tbl) <- c("All", "Asian", "Black", "Latino", "White")
descwn_tbl<- descwn_tbl %>%
    mutate_all(round, 1) %>%
    huxtable() %>%
    # insert_row(c("All", "Asian", "Black", "Latino", "White")) %>%
    insert_row(rep(NA, 5), after=2) %>%
    insert_column(c("Group", "Percent satisfied", "Difference", 
                    "Asian", "Black", "Latino", "White")) %>%
    set_number_format(everywhere, everywhere, "%5.1f") 
descwn_tbl

```

```{r wn-desc-latex, include=FALSE, echo=FALSE}
strfmt <- function(x) {ifelse(
    !is.na(as.numeric(x)),
    as.character(formatC(as.numeric(x), digits=1, format="f")),
    ""
)}
descwn_xt <- descwn_tbl[-1,]
names(descwn_xt) <- descwn_tbl[1,]
descwn_xt <- descwn_xt %>%
    mutate_at(vars(-Group), strfmt)%>%
    mutate_all(~sub("NA","", .)) %>%
    setNames(c("", descwn_tbl[1,-1]))

xtable(descwn_xt,
    align = c("l", "l", rep("R{4em}", 5)),
    caption =paste("Unconditional mean level of satisfaction and", 
                   "differences by race among residents of multiracial",
                   "neighborhoods"),
    label=("tab:descwn")
) %>% print(
        booktabs = TRUE,
        floating.environment = 'sidewaystable',
        caption.placement = 'top',
        include.rownames = FALSE,
        file = 'tables/within_descriptives.tex',
        sanitize.text.function = identity,
        timestamp = ''
)

```

## Regression anaysis of neighborhood satisfaction

Follow a similar process of model development as in the separate multiracial neighborhood and complete DC-area datasets. Add a fourth model that removes race from the model to examine whether removing the race variables improves the model fit. Include a neighborhood fixed effect in all models so that the coefficients represent the difference for residents *living in the same neighborhood*. 

1. Race and neighborhood fixed effects
2. Race, individual demographic characteristics (age, foreign-born, gender, children present, marital status, and education), and neighborhood fixed effects
3. Race, individual demographic characteristics, neighborhood experience (home ownership, years in the neighborhood, and perceived neighborhood size), and neighborhood fixed effects
4. No race, only individual demographic characteristics, neighborhood experience, and neighborhood fixed effects

```{r wn-regression-development}
m1 <- "raceeth + sample_tract"
m2 <- paste(m1, "+ agec + forbornc + manc + kidsc + marriedc",
            " + educ1c + educ3c + educ4c + educ5c")
m3 <- paste(m2, "+ ownc + nhdyrsc + nhdsize2c + nhdsize3c")
m4 <- sub("raceeth \\+ ", "", m3)

```

Estimate model parameters for each of the four models. Record the parameter estimates and standard errors in a table stored in file `tables/within.tex`. 

```{r wn-regression, warning=FALSE}
## Note: "non-integer #successes" warnings suppressed
m1wn <- with(dcas16svy, svyglm(
    as.formula(paste('satisfied ~', m1)), family=binomial)
    )

m2wn <- with(dcas16svy, svyglm(
    as.formula(paste('satisfied ~', m2)), family=binomial)
    )

m3wn <- with(dcas16svy, svyglm(
    as.formula(paste('satisfied ~', m3)), family=binomial)
    )

m4wn <- with(dcas16svy, svyglm(
    as.formula(paste('satisfied ~', m4)), family=binomial)
    )

wn_tbl <- report_models(
    MIcombine_aic(m1wn), MIcombine_aic(m2wn), 
    MIcombine_aic(m3wn), MIcombine_aic(m4wn),
    caption = paste(
        "Logistic regression coefficients and standard errors predicted",
        "from models estimating neighborhood satisfaction among residents", 
        "of mulitracial neighborhoods"
        ),
    label = "tab:within",
    reglabels = regression_labels,
    use.headers = TRUE
)
statrow <- nrow(wn_tbl)-3
wn_tbl <- insert_row(
    wn_tbl, c("Tract fixed effects", rep("X", 4)),after=statrow) %>%
    set_top_border(statrow+1, everywhere, TRUE) %>%
    set_top_border(statrow+2, everywhere, FALSE) %>% 
    set_top_padding(0) %>%
    set_bottom_padding(0)
cat(to_latex(wn_tbl), file="tables/within.tex")
wn_tbl

```

## Marginal Effect of Race on Neighborhood Satisfaction

Calculate the marginal effect of race on neighborhood satisfaction using white residents as the reference group. The function `MImargins()` is defined in the file `marginal_effects.R`. The function combines the standard errors of marginal effects from the multiply imputed datasets using Rubin's rules (following this [algorithm][]).

[algorithm]: https://stats.idre.ucla.edu/wp-content/uploads/2016/02/multipleimputation.pdf

```{r wn-mfx}
## Calculate partial effects of race
m1wn_mfx <- MImargins(m1wn, param="margins")
m3wn_mfx <- MImargins(m3wn, param="margins")

## Record marginal effects and standard errors in table and report
mfxwn <- inner_join(m1wn_mfx, m3wn_mfx, by="raceeth", 
                    suffix=c(".Unadjusted", ".Adjusted")) 

mfxwn_tbl <- mfxwn %>%
    mutate_at(vars(starts_with("val")), ~paste0(" ", round(.,3), " ")) %>%
    mutate_at(vars(starts_with("SE")), ~paste0("(", round(.,3), ")"))
kable(mfxwn_tbl, digits=3)

```

```{r wn-mfx-make-plt}
## Plot marginal effects and standard errors
mfxwn_long <- bind_rows(m1wn_mfx, m3wn_mfx) %>%
    mutate(model=relevel(factor(rep(c("Unadjusted", "Adjusted"), each=3)),
                         ref="Unadjusted"))
dodge_wd <- 0.25
wn_mfx_plt <- ggplot(mfxwn_long, 
       aes(x=raceeth, y=val, ymin=val-1.96*SE, ymax=val+1.96*SE,
           group=model, color=model, shape=model)) +
    geom_point(position=position_dodge(width=dodge_wd), size=2.15) +
    geom_linerange(size=.5, position=position_dodge(dodge_wd)) +
    geom_hline(yintercept=0, color="#666666") +
    scale_color_manual(values = c("#888888", "#222222")) +
    scale_x_discrete(
        labels=gsub("^(\\w)", "\\U\\1", mfxwn_long$raceeth, perl=TRUE)
    ) +
    scale_y_continuous(limits=c(-.21, .21)) +
    # scale_shape_discrete(labels=c("No controls", "With controls")) +
    labs(
        x = NULL,
        y = "Marginal effect",
        shape = NULL, color = NULL
    ) +
    theme_minimal() +
    theme(
        legend.position = "bottom",
        panel.grid.major.x = element_blank()
    )

wn_mfx_plt_cap <- paste(
    "Marginal effects of race on being satisfied in multiracial",
    "neighborhoods compared to white residents of multiracial neighborhoods"
)
```

```{r wn-mfx-plt, echo=FALSE, fig.cap=wn_mfx_plt_cap}
wn_mfx_plt
ggsave("images/marginal_effects_within.png", plot = wn_mfx_plt,
       width=6.75, units='in')
```

```{r wn-marginal-effects}
# mfxm1wn <- lapply(seq_along(m1wn), get.margins, m1wn) 
# nhwlink <- log(
#     mfxm1wn[["pred"]][["white"]] / (1 - mfxm1wn[["pred"]][["white"]])
#     )
# amem1wn <- mfxm1wn$AME_link %>%
#     mutate(
#         race = levels(dcas16$raceeth)[-1],
#         eta = nhwlink + AMEmi,
#         pred = plogis(eta)
#         # ame = plogis(eta) - plogis(nhwlink),
#         # lci = plogis(eta - 1.96*sqrt(Vmi)) - plogis(eta),
#         # uci = plogis(eta + 1.96*sqrt(Vmi)) - plogis(eta)
#         
#     )
# ggplot(amem1wn, aes(x=race, y=AMEmi, ymin=lci, ymax))
# 
# 
# amem1wn_plt <- ggplot(amem1wn, aes(x=))
# mfxm3wn <- lapply(seq_along(m3wn), get.margins, m3wn) %>%
#     calculate.pvals()
# 
# ```
# ```{r wn-predicted-values}
# varnames <- str_match_all(m3, "\\w+")[[1]][-1:-2]
# pred1wn <- MIpredict(m1wn, at="intercept", vars = varnames)
# pred3wn <- MIpredict(m3wn, at="intercept", vars = varnames)
# 
# wn_pred_tbl <- pred1wn %>%
#     select(raceeth, p) %>%
#     inner_join(pred3wn %>% select(raceeth, p), by="raceeth") %>%
#     arrange(raceeth)
# names(wn_pred_tbl) <- c("Race", "Unadjusted", "Adjusted")
# wn_pred_tbl

```

```{r wn-prediction-plt}
# pred1wn$model <- "Unadjusted"
# pred3wn$model <- "Adjusted"
# 
# wn_pred_long <- bind_rows(pred1wn, pred3wn) %>%
#     mutate(
#         race = ordered(raceeth, levels=raceordlevs),
#         model = relevel(factor(model), ref="Unadjusted")
#         )
# wn_pred_plt <-ggplot(wn_pred_long, aes(
#     x=race, y=p, ymax=uci, ymin=lci, 
#     group=model, color=model, shape=model
# )) +
#     geom_point(size=2.15, position=position_dodge(dodge_wd)) +
#     geom_linerange(size=.5, position=position_dodge(dodge_wd)) +
#     scale_color_manual(values = c("#888888", "#222222")) +
#     scale_x_discrete(
#         labels=gsub("^(\\w)", "\\U\\1", raceordlevs, perl=TRUE)
#     ) +
#     scale_y_continuous(
#         limits=c(.45, 1), breaks=seq(.5, 1.0, .1)
#     ) +
#     labs(
#         x = NULL,
#         y = "Probability",
#         shape = NULL, color = NULL
#     ) +
#     theme_minimal() +
#     theme(
#         legend.position = "bottom",
#         panel.grid.major.x = element_blank()
#     )
# wn_pred_plt
```
